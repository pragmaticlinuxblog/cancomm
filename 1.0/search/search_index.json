{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LibCanComm is a Linux shared library for CAN communication. Its goal is to make it easier for application developers to access and exchange data with nodes on a CAN bus. The library supports both CAN classic and CAN FD message formats. LibCanComm embeds functionality for: Listing the available SocketCAN devices on the user's system. Connecting to a SocketCAN device. Transmitting and receiving CAN messages. The library itself is developed in the C programming language. While designing the library's API, special care was taken to make it uncomplicated to create bindings for other programming languages. As such, it should be straightforward to access the LibCanComm shared library from different programming languages, such as Python, Java, C#, Rust, Go, Ruby, Object Pascal, etc. Note that LibCanComm does not provide functionality related to configuring and bringing up SocketCAN devices on the user's system. The excellent LibSocketCan library already covers this, if you want to perform these tasks programmatically. Although most users tend to handle this manually themselves with calls to ip link or automate it with the help of systemd-networkd . Installation instructions This section presents step-by-step instruction for downloading, building and installing LibCanComm onto your Linux system. Install build dependencies To download, build and install LibCanComm onto your Linux system, you just need C development and Git related package on your system. The installation instructions for popular Linux distributions: Debian / Ubuntu / Raspberry PI OS: sudo apt install git gcc g++ gdb make cmake Fedora: sudo dnf install git gcc g++ gdb make cmake openSUSE: sudo zypper install git gcc gcc-c++ gdb make cmake Download the code To obtain the code, you can either download the latest stable release from the GitHub repository: https://github.com/pragmaticlinuxblog/cancomm/releases Or directly clone the latest development version: git clone https://github.com/pragmaticlinuxblog/cancomm.git ~/LibCanComm It's recommended to stick with a stable release. The following sections assume that you either cloned or extracted the code to directory ~/LibCanComm . Generate the build environment After downloading the code, you can automatically generate the build environment with the help of CMake. Open your terminal, go to the build subdirectory and run the cmake .. command: cd ~/LibCanComm/build cmake .. Build the library With the build environment generated, you can continue with building the shared library. Run this command: make all Install the library As a final step, you install the shared library onto your system and run ldconfig to register it: sudo make install sudo ldconfig Bring up a SocketCAN device Before your application can communicate with other nodes on the CAN bus, you need to connect a CAN adapter supported by the Linux kernel's SocketCAN subsystem. For example a Peak PCAN-USB or a Kvaser LeafLight . Once connected, it shows up as a SocketCAN device on your PC. By default, the SocketCAN device is not yet configured and brought in the UP state. The following tutorials explain in details how to perform these tasks. Note that if you don't have access to a CAN adapter, you can continue with a virtual SocketCAN device. How to create a virtual CAN interface on Linux Automatically bring up a SocketCAN interface on boot CAN communication on the Raspberry PI with SocketCAN Code sample This section presents a few brief code samples to give you an idea of how you use LibCanComm in your own application. For more information refer to the example application and the API reference . Listing all available SocketCAN devices: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cancomm.h> #include <stdio.h> int main ( void ) { cancomm_t canCommCtx ; uint32_t canDeviceCnt ; uint32_t canDeviceIdx ; /* Create a new context. */ canCommCtx = cancomm_new (); /* List all SocketCAN devices found on the system. */ canDeviceCnt = cancomm_devices_buildlist ( canCommCtx ); for ( canDeviceIdx = 0 ; canDeviceIdx < canDeviceCnt ; canDeviceIdx ++ ) { printf ( \"%s \\n \" , cancomm_devices_name ( canCommCtx , canDeviceIdx )); } /* Release the context. */ cancomm_free ( canCommCtx ); } Connecting to a SocketCAN device and transmitting a CAN message: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <cancomm.h> int main ( void ) { cancomm_t canCommCtx ; uint32_t canId = 0x123 ; uint8_t canExt = CANCOMM_FALSE ; /* 11-bit identifier */ uint8_t canData [] = { 0x01 , 0x02 , 0x55 , 0xAA }; uint8_t canFlags = 0 ; /* classic CAN. */ uint64_t canTimestamp = 0 ; /* Create a new context. */ canCommCtx = cancomm_new (); /* Connect to SocketCAN device \"vcan0\". */ cancomm_connect ( canCommCtx , \"vcan0\" ); /* Transmit the CAN message. */ cancomm_transmit ( canCommCtx , canId , canExt , 4 , canData , canFlags , & canTimestamp ); /* Release the context. */ cancomm_free ( canCommCtx ); } License","title":"Getting started"},{"location":"#installation-instructions","text":"This section presents step-by-step instruction for downloading, building and installing LibCanComm onto your Linux system.","title":"Installation instructions"},{"location":"#install-build-dependencies","text":"To download, build and install LibCanComm onto your Linux system, you just need C development and Git related package on your system. The installation instructions for popular Linux distributions: Debian / Ubuntu / Raspberry PI OS: sudo apt install git gcc g++ gdb make cmake Fedora: sudo dnf install git gcc g++ gdb make cmake openSUSE: sudo zypper install git gcc gcc-c++ gdb make cmake","title":"Install build dependencies"},{"location":"#download-the-code","text":"To obtain the code, you can either download the latest stable release from the GitHub repository: https://github.com/pragmaticlinuxblog/cancomm/releases Or directly clone the latest development version: git clone https://github.com/pragmaticlinuxblog/cancomm.git ~/LibCanComm It's recommended to stick with a stable release. The following sections assume that you either cloned or extracted the code to directory ~/LibCanComm .","title":"Download the code"},{"location":"#generate-the-build-environment","text":"After downloading the code, you can automatically generate the build environment with the help of CMake. Open your terminal, go to the build subdirectory and run the cmake .. command: cd ~/LibCanComm/build cmake ..","title":"Generate the build environment"},{"location":"#build-the-library","text":"With the build environment generated, you can continue with building the shared library. Run this command: make all","title":"Build the library"},{"location":"#install-the-library","text":"As a final step, you install the shared library onto your system and run ldconfig to register it: sudo make install sudo ldconfig","title":"Install the library"},{"location":"#bring-up-a-socketcan-device","text":"Before your application can communicate with other nodes on the CAN bus, you need to connect a CAN adapter supported by the Linux kernel's SocketCAN subsystem. For example a Peak PCAN-USB or a Kvaser LeafLight . Once connected, it shows up as a SocketCAN device on your PC. By default, the SocketCAN device is not yet configured and brought in the UP state. The following tutorials explain in details how to perform these tasks. Note that if you don't have access to a CAN adapter, you can continue with a virtual SocketCAN device. How to create a virtual CAN interface on Linux Automatically bring up a SocketCAN interface on boot CAN communication on the Raspberry PI with SocketCAN","title":"Bring up a SocketCAN device"},{"location":"#code-sample","text":"This section presents a few brief code samples to give you an idea of how you use LibCanComm in your own application. For more information refer to the example application and the API reference . Listing all available SocketCAN devices: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cancomm.h> #include <stdio.h> int main ( void ) { cancomm_t canCommCtx ; uint32_t canDeviceCnt ; uint32_t canDeviceIdx ; /* Create a new context. */ canCommCtx = cancomm_new (); /* List all SocketCAN devices found on the system. */ canDeviceCnt = cancomm_devices_buildlist ( canCommCtx ); for ( canDeviceIdx = 0 ; canDeviceIdx < canDeviceCnt ; canDeviceIdx ++ ) { printf ( \"%s \\n \" , cancomm_devices_name ( canCommCtx , canDeviceIdx )); } /* Release the context. */ cancomm_free ( canCommCtx ); } Connecting to a SocketCAN device and transmitting a CAN message: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <cancomm.h> int main ( void ) { cancomm_t canCommCtx ; uint32_t canId = 0x123 ; uint8_t canExt = CANCOMM_FALSE ; /* 11-bit identifier */ uint8_t canData [] = { 0x01 , 0x02 , 0x55 , 0xAA }; uint8_t canFlags = 0 ; /* classic CAN. */ uint64_t canTimestamp = 0 ; /* Create a new context. */ canCommCtx = cancomm_new (); /* Connect to SocketCAN device \"vcan0\". */ cancomm_connect ( canCommCtx , \"vcan0\" ); /* Transmit the CAN message. */ cancomm_transmit ( canCommCtx , canId , canExt , 4 , canData , canFlags , & canTimestamp ); /* Release the context. */ cancomm_free ( canCommCtx ); }","title":"Code sample"},{"location":"#license","text":"","title":"License"},{"location":"api/","text":"This section provides a full reference of all the functions, macros and types that LibCanComm offers. Types can_comm_t typedef void * cancomm_t Opaque pointer for the CAN communication context. Macros Macro Description CANCOMM_TRUE Boolean true value. CANCOMM_FALSE Boolean false value. CANCOMM_FLAG_CANFD_MSG Bit flag to indicate that the message is a CAN FD message. CANCOMM_FLAG_CANERR_MSG Bit flag to indicate that the message is a CAN error frame. Functions cancomm_new cancomm_t cancomm_new ( void ) Creates a new CAN communication context. All subsequent library functions need this context. The context makes it possible for multiple applications to make use of this library. Return value Newly created context, if successful. NULL otherwise. Example - Create a new context: 1 2 3 4 5 6 7 8 9 10 11 12 cancomm_t canCommCtx ; /* Create a new CAN communication context. */ canCommCtx = cancomm_new (); if ( canCommCtx != NULL ) { printf ( \"[INFO] Created CAN communication context. \\n \" ); } else { printf ( \"[ERROR] Could not create CAN communication context. \\n \" ); } cancomm_free void cancomm_free ( cancomm_t ctx ) Releases the context. Should be called for each CAN communication context, created with function cancomm_new() , once you no longer need it. Parameter Description ctx CAN communication context. Example - Release a context: 1 2 3 4 5 6 /* Release the CAN communication context. */ if ( canCommCtx != NULL ) { cancomm_free ( canCommCtx ); printf ( \"[INFO] Released CAN communication context. \\n \" ); } cancomm_connect uint8_t cancomm_connect ( cancomm_t ctx , char const * device ) Connects to the specified SocketCAN device. Note that you can use the functions cancomm_devices_buildlist() and cancomm_devices_name() to determine the names of the SocketCAN devices known to the system. Alternatively, you can run command ip addr in the terminal to find out about the SocketCAN devices know to the system. This function automatically figures out if the SocketCAN device supports CAN FD, in addition to CAN classic. Parameter Description ctx CAN communication context. device Null terminated string with the SocketCAN device name, e.g. \"can0\" . Return value CANCOMM_TRUE if successfully connected to the SocketCAN device, CANCOMM_FALSE otherwise. Example 1 - Connect to the SocketCAN device with a specific name: 1 2 3 4 5 /* Connect to SocketCAN device with name \"vcan0\". */ if ( cancomm_connect ( canCommCtx , \"vcan0\" ) == CANCOMM_TRUE ) { printf ( \"[INFO] Connected to CAN device. \\n \" ); } Example 2 - Connect to the first SocketCAN device found on the system: 1 2 3 4 5 6 7 8 9 10 11 12 13 /* Build list with all SocketCAN devices currently known to the system * and only continue if at least one is present. */ if ( cancomm_devices_buildlist ( canCommCtx ) > 0 ) { /* Obtain the name of the first SocketCAN device that was found. */ char * canDevice = cancomm_devices_name ( canCommCtx , 0 ); /* Connect to this SocketCAN device. */ if ( cancomm_connect ( canCommCtx , canDevice ) == CANCOMM_TRUE ) { printf ( \"[INFO] Connected to CAN device '%s'. \\n \" , canDevice ); } } cancomm_disconnect void cancomm_disconnect ( cancomm_t ctx ) Disconnects from the SocketCAN device. Parameter Description ctx CAN communication context. Example - Disconnect from a SocketCAN device: 1 2 cancomm_disconnect ( canCommCtx ); printf ( \"[INFO] Disconnected from CAN device. \\n \" ); cancomm_transmit uint8_t cancomm_transmit ( cancomm_t ctx , uint32_t id , uint8_t ext , uint8_t len , uint8_t const * data , uint8_t flags , uint64_t * timestamp ) Submits a CAN message for transmission. Parameter Description ctx CAN communication context. id CAN message identifier. ext Set to CANCOMM_FALSE for an 11-bit message identifier, to CANCOMM_TRUE for 29-bit. len Number of CAN message data bytes. Max 8 for a CAN classic message, max 64 for a CAN FD message. data Pointer to array with data bytes. flags Bit flags for providing additional information about how to transmit the message: - CANCOMM_FLAG_CANFD_MSG : The message is CAN FD and not CAN classic. Ignored for non CAN FD SocketCAN devices. timestamp Pointer to where the timestamp (microseconds) of the message is stored. Return value CANCOMM_TRUE if successfully submitted the message for transmission. CANCOMM_FALSE otherwise. Example 1 - Transmit a CAN classic message with 11-bit identifier: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canId = 0x123 ; uint8_t canExt = CANCOMM_FALSE ; /* 11-bit identifier */ uint8_t canData [] = { 0x01 , 0x02 , 0x55 , 0xAA }; uint8_t canFlags = 0 ; /* CAN classic. */ uint64_t canTimestamp = 0 ; /* Transmit the CAN message. */ if ( cancomm_transmit ( canCommCtx , canId , canExt , 4 , canData , canFlags , & canTimestamp ) == CANCOMM_TRUE ) { printf ( \"[INFO] Transmitted message at %llu us. \\n \" , canTimestamp ); } Example 2 - Transmit a CAN classic message with 29-bit identifier: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canId = 0x123A5 ; uint8_t canExt = CANCOMM_TRUE ; /* 29-bit identifier */ uint8_t canData [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; uint8_t canFlags = 0 ; /* CAN classic. */ uint64_t canTimestamp = 0 ; /* Transmit the CAN message. */ if ( cancomm_transmit ( canCommCtx , canId , canExt , 8 , canData , canFlags , & canTimestamp ) == CANCOMM_TRUE ) { printf ( \"[INFO] Transmitted message at %llu us. \\n \" , canTimestamp ); } Example 3 - Transmit a CAN FD message with 11-bit identifier: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canId = 0x234 ; uint8_t canExt = CANCOMM_FALSE ; /* 11-bit identifier */ uint8_t canData [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 }; uint8_t canFlags = CANCOMM_FLAG_CANFD_MSG ; /* CAN FD. */ uint64_t canTimestamp = 0 ; /* Transmit the CAN message. */ if ( cancomm_transmit ( canCommCtx , canId , canExt , 16 , canData , canFlags , & canTimestamp ) == CANCOMM_TRUE ) { printf ( \"[INFO] Transmitted message at %llu us. \\n \" , canTimestamp ); } cancomm_receive uint8_t cancomm_receive ( cancomm_t ctx , uint32_t * id , uint8_t * ext , uint8_t * len , uint8_t * data , uint8_t * flags , uint64_t * timestamp ) Reads a possibly received CAN message or CAN error frame in a non-blocking manner. Parameter Description ctx CAN communication context. id Pointer to where the CAN message identifier is stored. ext Pointer to where the CAN identifier type is stored. CANCOMM_FALSE for an 11-bit message identifier, CANCOMM_TRUE for 29-bit. len Pointer to where the number of CAN message data bytes is stored. data Pointer to array where the data bytes are stored. flags Pointer to where the bit flags are stored for providing additional information about the received message: - CANCOMM_FLAG_CANFD_MSG : The message is CAN FD and not CAN classic. - CANCOMM_FLAG_CANERR_MSG : The message is a CAN error frame. timestamp Pointer to where the timestamp (microseconds) of the message is stored. Return value CANCOMM_TRUE if a new message was received and copied. CANCOMM_FALSE otherwise. Example - Receiving CAN messages and error frames: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 uint32_t canId = 0 ; uint8_t canExt = CANCOMM_FALSE ; uint8_t canLen = 0 ; uint8_t canData [ 64 ]; uint8_t canFlags = 0 ; uint64_t canTimestamp = 0 ; /* Check for the reception of a CAN message or error frame. */ if ( cancomm_receive ( canCommCtx , & canId , & canExt , & canLen , & canData [ 0 ], & canFlags , & canTimestamp ) == CANCOMM_TRUE ) { /* Was is an error frame? */ if (( canFlags & CANCOMM_FLAG_CANERR_MSG ) == CANCOMM_FLAG_CANERR_MSG ) { printf ( \"[INFO] Error frame received at %llu us. \\n \" , canTimestamp ); } /* It was a CAN message. */ else { /* Was it a CAN FD message? */ if (( canFlags & CANCOMM_FLAG_CANFD_MSG ) == CANCOMM_FLAG_CANFD_MSG ) { printf ( \"[INFO] Received CAN FD message with ID %Xh at %llu us. \\n \" , canId , canTimestamp ); } /* It was a CAN classic message. */ else { printf ( \"[INFO] Received CAN classic message with ID %Xh at %llu us. \\n \" , canId , canTimestamp ); } } } cancomm_devices_buildlist uint8_t cancomm_devices_buildlist ( cancomm_t ctx ) Builds a list with all the CAN device names currently present on the system. Basically an internal array with strings such as \"can0\" , \"vcan0\" , etc. Afterwards, you can call cancomm_devices_name() to retrieve the name of a specific SocketCAN device, using its array index. Parameter Description ctx CAN communication context. Return value The total number of CAN devices currently present on the system, or 0 if none were found or in case of an error. Example - Detecting all SocketCAN devices known to the system: 1 2 3 uint32_t canDeviceCnt ; canDeviceCnt = cancomm_devices_buildlist ( canCommCtx ); cancomm_devices_name char * cancomm_devices_name ( cancomm_t ctx , uint8_t idx ) Obtains the SocketCAN device name at the specified index of the internal list with CAN devices, created by function cancomm_devices_buildlist() . You could use this SocketCAN device name when calling cancomm_connect() . Note that you should call cancomm_devices_buildlist() at least once, before calling this function. Parameter Description ctx CAN communication context. idx Zero based index into the device list. Return value The CAN device name at the specified index, or NULL in case of an error. Example - Listing all SocketCAN devices known to the system: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canDeviceCnt ; uint32_t canDeviceIdx ; char * canDevice ; printf ( \"[INFO] Detecting SocketCAN devices: \" ); canDeviceCnt = cancomm_devices_buildlist ( canCommCtx ); for ( canDeviceIdx = 0 ; canDeviceIdx < canDeviceCnt ; canDeviceIdx ++ ) { printf ( \"'%s' \" , cancomm_devices_name ( canCommCtx , canDeviceIdx )); } printf ( \"(%d found). \\n \" , canDeviceCnt );","title":"API reference"},{"location":"api/#types","text":"","title":"Types"},{"location":"api/#can_comm_t","text":"typedef void * cancomm_t Opaque pointer for the CAN communication context.","title":"can_comm_t"},{"location":"api/#macros","text":"Macro Description CANCOMM_TRUE Boolean true value. CANCOMM_FALSE Boolean false value. CANCOMM_FLAG_CANFD_MSG Bit flag to indicate that the message is a CAN FD message. CANCOMM_FLAG_CANERR_MSG Bit flag to indicate that the message is a CAN error frame.","title":"Macros"},{"location":"api/#functions","text":"","title":"Functions"},{"location":"api/#cancomm_new","text":"cancomm_t cancomm_new ( void ) Creates a new CAN communication context. All subsequent library functions need this context. The context makes it possible for multiple applications to make use of this library. Return value Newly created context, if successful. NULL otherwise. Example - Create a new context: 1 2 3 4 5 6 7 8 9 10 11 12 cancomm_t canCommCtx ; /* Create a new CAN communication context. */ canCommCtx = cancomm_new (); if ( canCommCtx != NULL ) { printf ( \"[INFO] Created CAN communication context. \\n \" ); } else { printf ( \"[ERROR] Could not create CAN communication context. \\n \" ); }","title":"cancomm_new"},{"location":"api/#cancomm_free","text":"void cancomm_free ( cancomm_t ctx ) Releases the context. Should be called for each CAN communication context, created with function cancomm_new() , once you no longer need it. Parameter Description ctx CAN communication context. Example - Release a context: 1 2 3 4 5 6 /* Release the CAN communication context. */ if ( canCommCtx != NULL ) { cancomm_free ( canCommCtx ); printf ( \"[INFO] Released CAN communication context. \\n \" ); }","title":"cancomm_free"},{"location":"api/#cancomm_connect","text":"uint8_t cancomm_connect ( cancomm_t ctx , char const * device ) Connects to the specified SocketCAN device. Note that you can use the functions cancomm_devices_buildlist() and cancomm_devices_name() to determine the names of the SocketCAN devices known to the system. Alternatively, you can run command ip addr in the terminal to find out about the SocketCAN devices know to the system. This function automatically figures out if the SocketCAN device supports CAN FD, in addition to CAN classic. Parameter Description ctx CAN communication context. device Null terminated string with the SocketCAN device name, e.g. \"can0\" . Return value CANCOMM_TRUE if successfully connected to the SocketCAN device, CANCOMM_FALSE otherwise. Example 1 - Connect to the SocketCAN device with a specific name: 1 2 3 4 5 /* Connect to SocketCAN device with name \"vcan0\". */ if ( cancomm_connect ( canCommCtx , \"vcan0\" ) == CANCOMM_TRUE ) { printf ( \"[INFO] Connected to CAN device. \\n \" ); } Example 2 - Connect to the first SocketCAN device found on the system: 1 2 3 4 5 6 7 8 9 10 11 12 13 /* Build list with all SocketCAN devices currently known to the system * and only continue if at least one is present. */ if ( cancomm_devices_buildlist ( canCommCtx ) > 0 ) { /* Obtain the name of the first SocketCAN device that was found. */ char * canDevice = cancomm_devices_name ( canCommCtx , 0 ); /* Connect to this SocketCAN device. */ if ( cancomm_connect ( canCommCtx , canDevice ) == CANCOMM_TRUE ) { printf ( \"[INFO] Connected to CAN device '%s'. \\n \" , canDevice ); } }","title":"cancomm_connect"},{"location":"api/#cancomm_disconnect","text":"void cancomm_disconnect ( cancomm_t ctx ) Disconnects from the SocketCAN device. Parameter Description ctx CAN communication context. Example - Disconnect from a SocketCAN device: 1 2 cancomm_disconnect ( canCommCtx ); printf ( \"[INFO] Disconnected from CAN device. \\n \" );","title":"cancomm_disconnect"},{"location":"api/#cancomm_transmit","text":"uint8_t cancomm_transmit ( cancomm_t ctx , uint32_t id , uint8_t ext , uint8_t len , uint8_t const * data , uint8_t flags , uint64_t * timestamp ) Submits a CAN message for transmission. Parameter Description ctx CAN communication context. id CAN message identifier. ext Set to CANCOMM_FALSE for an 11-bit message identifier, to CANCOMM_TRUE for 29-bit. len Number of CAN message data bytes. Max 8 for a CAN classic message, max 64 for a CAN FD message. data Pointer to array with data bytes. flags Bit flags for providing additional information about how to transmit the message: - CANCOMM_FLAG_CANFD_MSG : The message is CAN FD and not CAN classic. Ignored for non CAN FD SocketCAN devices. timestamp Pointer to where the timestamp (microseconds) of the message is stored. Return value CANCOMM_TRUE if successfully submitted the message for transmission. CANCOMM_FALSE otherwise. Example 1 - Transmit a CAN classic message with 11-bit identifier: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canId = 0x123 ; uint8_t canExt = CANCOMM_FALSE ; /* 11-bit identifier */ uint8_t canData [] = { 0x01 , 0x02 , 0x55 , 0xAA }; uint8_t canFlags = 0 ; /* CAN classic. */ uint64_t canTimestamp = 0 ; /* Transmit the CAN message. */ if ( cancomm_transmit ( canCommCtx , canId , canExt , 4 , canData , canFlags , & canTimestamp ) == CANCOMM_TRUE ) { printf ( \"[INFO] Transmitted message at %llu us. \\n \" , canTimestamp ); } Example 2 - Transmit a CAN classic message with 29-bit identifier: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canId = 0x123A5 ; uint8_t canExt = CANCOMM_TRUE ; /* 29-bit identifier */ uint8_t canData [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; uint8_t canFlags = 0 ; /* CAN classic. */ uint64_t canTimestamp = 0 ; /* Transmit the CAN message. */ if ( cancomm_transmit ( canCommCtx , canId , canExt , 8 , canData , canFlags , & canTimestamp ) == CANCOMM_TRUE ) { printf ( \"[INFO] Transmitted message at %llu us. \\n \" , canTimestamp ); } Example 3 - Transmit a CAN FD message with 11-bit identifier: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canId = 0x234 ; uint8_t canExt = CANCOMM_FALSE ; /* 11-bit identifier */ uint8_t canData [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 }; uint8_t canFlags = CANCOMM_FLAG_CANFD_MSG ; /* CAN FD. */ uint64_t canTimestamp = 0 ; /* Transmit the CAN message. */ if ( cancomm_transmit ( canCommCtx , canId , canExt , 16 , canData , canFlags , & canTimestamp ) == CANCOMM_TRUE ) { printf ( \"[INFO] Transmitted message at %llu us. \\n \" , canTimestamp ); }","title":"cancomm_transmit"},{"location":"api/#cancomm_receive","text":"uint8_t cancomm_receive ( cancomm_t ctx , uint32_t * id , uint8_t * ext , uint8_t * len , uint8_t * data , uint8_t * flags , uint64_t * timestamp ) Reads a possibly received CAN message or CAN error frame in a non-blocking manner. Parameter Description ctx CAN communication context. id Pointer to where the CAN message identifier is stored. ext Pointer to where the CAN identifier type is stored. CANCOMM_FALSE for an 11-bit message identifier, CANCOMM_TRUE for 29-bit. len Pointer to where the number of CAN message data bytes is stored. data Pointer to array where the data bytes are stored. flags Pointer to where the bit flags are stored for providing additional information about the received message: - CANCOMM_FLAG_CANFD_MSG : The message is CAN FD and not CAN classic. - CANCOMM_FLAG_CANERR_MSG : The message is a CAN error frame. timestamp Pointer to where the timestamp (microseconds) of the message is stored. Return value CANCOMM_TRUE if a new message was received and copied. CANCOMM_FALSE otherwise. Example - Receiving CAN messages and error frames: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 uint32_t canId = 0 ; uint8_t canExt = CANCOMM_FALSE ; uint8_t canLen = 0 ; uint8_t canData [ 64 ]; uint8_t canFlags = 0 ; uint64_t canTimestamp = 0 ; /* Check for the reception of a CAN message or error frame. */ if ( cancomm_receive ( canCommCtx , & canId , & canExt , & canLen , & canData [ 0 ], & canFlags , & canTimestamp ) == CANCOMM_TRUE ) { /* Was is an error frame? */ if (( canFlags & CANCOMM_FLAG_CANERR_MSG ) == CANCOMM_FLAG_CANERR_MSG ) { printf ( \"[INFO] Error frame received at %llu us. \\n \" , canTimestamp ); } /* It was a CAN message. */ else { /* Was it a CAN FD message? */ if (( canFlags & CANCOMM_FLAG_CANFD_MSG ) == CANCOMM_FLAG_CANFD_MSG ) { printf ( \"[INFO] Received CAN FD message with ID %Xh at %llu us. \\n \" , canId , canTimestamp ); } /* It was a CAN classic message. */ else { printf ( \"[INFO] Received CAN classic message with ID %Xh at %llu us. \\n \" , canId , canTimestamp ); } } }","title":"cancomm_receive"},{"location":"api/#cancomm_devices_buildlist","text":"uint8_t cancomm_devices_buildlist ( cancomm_t ctx ) Builds a list with all the CAN device names currently present on the system. Basically an internal array with strings such as \"can0\" , \"vcan0\" , etc. Afterwards, you can call cancomm_devices_name() to retrieve the name of a specific SocketCAN device, using its array index. Parameter Description ctx CAN communication context. Return value The total number of CAN devices currently present on the system, or 0 if none were found or in case of an error. Example - Detecting all SocketCAN devices known to the system: 1 2 3 uint32_t canDeviceCnt ; canDeviceCnt = cancomm_devices_buildlist ( canCommCtx );","title":"cancomm_devices_buildlist"},{"location":"api/#cancomm_devices_name","text":"char * cancomm_devices_name ( cancomm_t ctx , uint8_t idx ) Obtains the SocketCAN device name at the specified index of the internal list with CAN devices, created by function cancomm_devices_buildlist() . You could use this SocketCAN device name when calling cancomm_connect() . Note that you should call cancomm_devices_buildlist() at least once, before calling this function. Parameter Description ctx CAN communication context. idx Zero based index into the device list. Return value The CAN device name at the specified index, or NULL in case of an error. Example - Listing all SocketCAN devices known to the system: 1 2 3 4 5 6 7 8 9 10 11 uint32_t canDeviceCnt ; uint32_t canDeviceIdx ; char * canDevice ; printf ( \"[INFO] Detecting SocketCAN devices: \" ); canDeviceCnt = cancomm_devices_buildlist ( canCommCtx ); for ( canDeviceIdx = 0 ; canDeviceIdx < canDeviceCnt ; canDeviceIdx ++ ) { printf ( \"'%s' \" , cancomm_devices_name ( canCommCtx , canDeviceIdx )); } printf ( \"(%d found). \\n \" , canDeviceCnt );","title":"cancomm_devices_name"},{"location":"example/","text":"The example/ subdirectory contains an example application that you can use. Both as a reference and as a template for developing your own CAN enabled application. This section covers how to build the example application and how you can test that it works. It is assumed that you already configured and enabled a SocketCAN device on your Linux system. Refer to the section on how to bring up a SocketCAN device for more info. The example application leverages CMake to automatically generate the build environment. However, this is not a requirement for building your own application, based on LibCanComm. Refer to this tutorial for details on how to properly link a shared library, such as LibCanComm, to your own C or C++ application. Building the example application This section shows you how to build the example application directly from the terminal. When you develop your own CAN enabled application, you probably want to opt for a graphical development environment along the lines of Visual Studio Code, as described in this tutorial: Import a CMake project into Visual Studio Code To build the example application using the terminal, open up your terminal and change into directory example/build/ . Next, generate the build environment and continue with building the application: cd ~/LibCanComm/example/build cmake .. make all Once the build operation completes, you can find the example executable in the ~/LibCanComm/example/build directory. Install can-utils Before we take the example application for a spin, let's first install the can-utils package on our Linux system. It includes the utilities cansend and candump for sending and logging CAN messages, respectively. The installation instructions for popular Linux distributions: Ubuntu/Debian: sudo apt install can-utils Fedora: sudo dnf install can-utils openSUSE: sudo zypper install canutils Running the example application The example application connects to the first SocketCAN network device found on your Linux system. Once connected, it enters its program loop to poll for the reception of CAN messages. Upon reception of a CAN message, it increments the CAN identifier and sends the message back onto the CAN bus. Assuming that your terminal is still opened in directory example/build/ , you start the example application with command: ./example To test that it works, open up another terminal screen and send a CAN message using the cansend utility: cansend vcan0 123#00FFAA5501020304 The following screenshots assumes your SocketCAN device is called vcan0 . The top terminal screen runs the example application, the middle one is used to send a CAN message and the bottom one shows all CAN message activity: To exit the example application, press CTRL + C .","title":"Example"},{"location":"example/#building-the-example-application","text":"This section shows you how to build the example application directly from the terminal. When you develop your own CAN enabled application, you probably want to opt for a graphical development environment along the lines of Visual Studio Code, as described in this tutorial: Import a CMake project into Visual Studio Code To build the example application using the terminal, open up your terminal and change into directory example/build/ . Next, generate the build environment and continue with building the application: cd ~/LibCanComm/example/build cmake .. make all Once the build operation completes, you can find the example executable in the ~/LibCanComm/example/build directory.","title":"Building the example application"},{"location":"example/#install-can-utils","text":"Before we take the example application for a spin, let's first install the can-utils package on our Linux system. It includes the utilities cansend and candump for sending and logging CAN messages, respectively. The installation instructions for popular Linux distributions: Ubuntu/Debian: sudo apt install can-utils Fedora: sudo dnf install can-utils openSUSE: sudo zypper install canutils","title":"Install can-utils"},{"location":"example/#running-the-example-application","text":"The example application connects to the first SocketCAN network device found on your Linux system. Once connected, it enters its program loop to poll for the reception of CAN messages. Upon reception of a CAN message, it increments the CAN identifier and sends the message back onto the CAN bus. Assuming that your terminal is still opened in directory example/build/ , you start the example application with command: ./example To test that it works, open up another terminal screen and send a CAN message using the cansend utility: cansend vcan0 123#00FFAA5501020304 The following screenshots assumes your SocketCAN device is called vcan0 . The top terminal screen runs the example application, the middle one is used to send a CAN message and the bottom one shows all CAN message activity: To exit the example application, press CTRL + C .","title":"Running the example application"}]}